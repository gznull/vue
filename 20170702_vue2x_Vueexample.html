<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>vue实例</title>
    <script type="text/javascript" src="vue/vue.js"></script>
</head>
<body>

</body>
    <script type="text/javascript">
        /*构造器
        * var vm=new Vue({})
        * 入参对象 数据、模板、挂载元素、方法、生命周期钩子等选项
        * 属性
        * 注意1：如果在实例创建之后添加新的属性到实例上，它不会触发视图更新
        * 注意2:Vue 实例暴露了一些有用的实例属性与方法。这些属性与方法都有前缀 $
        * $data,#el,$watch（监听）
        * 箭头函数
        * 不要在实例属性或者回调函数中（如 vm.$watch('a',newVal=>this.myMethod()))视同箭头函数因为箭头函数绑定父级上下文
        * ，所以 this 不会像预想的一样是 Vue 实例，而是 this.myMethod 未被定义
        *
        * vue生命周期:
        * vue实例化之前经过一系列初始化过程,实例需要配置数据观测(data observer)、编译模版、挂载实例到 DOM ，然后在数据变
        * 化时更新 DOM
        * 在这个过程中，实例也会调用一些 生命周期钩子 ，这就给我们提供了执行自定义逻辑的机会。例如，created 这个钩子在实
        * 例被创建之后被调用在实例生命周期的不同阶段调用时mounted、 updated 、destroyed 。钩子的 this 指向调用它的 Vue 实例
        *
        * vue没有控制器的概念组件逻辑是可以分布在这些钩子中
        * 实例化->观察数据->初始化计算引用属性->判断el属性有没有选项->(不存在的情况下就增加一个)(存在的情况下就判断有没
        * 有模板)->(如果有模板就将编辑模板存放到到底层然后读取)(如果没有模板就直接接用html的模板作为引用)->创建vm.$el然
        * 后来替换el 属性里面的值->更新数据->更新前和更新后(观察虚拟的dom有没有更新有更新就换新的dom然后在做更新操作)
        * ->回调结构后销毁(销毁虚拟寄存的dom)->拆御可视的东西.子组件和事件的监听->销毁
        *
        * */
    </script>
</html>